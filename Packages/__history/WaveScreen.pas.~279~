unit WaveScreen;

interface

uses
  System.SysUtils, System.Classes, Vcl.Controls, Vcl.ExtCtrls, Vcl.MPlayer, MyType,
  Vcl.StdCtrls, WinAPI.Messages, System.Types, Vcl.Graphics, Vcl.Forms, WavData, PaintWave,
  WaveScrollBar;

const
  imNearest = 0;
  imLine = 1;
  imSinC = 2;
  imCubic = 3;

type
  TBig = array[0..0] of Integer;

  TWaveScreen = class(TPanel)
  private
    FPaintBox: TWSPaintBox;
    FScrollBar: TWSScrollBar;

    FNotRepaint: Boolean;

    FAutoScroll: Boolean;

    FWavData: TWavData;
    FDisplayedData: TDisplayedData;

    FYScale: Real;

    // Текущая позиция курсора в Сэмплах
    FCursorPosition: Integer;

    // Текущая позиция "волны" в Сэмплах
    FWavePosition: Integer;

    FVisibleInterval: TInterval;

    procedure PaintWS(Sender: TObject);

    // Установка и чтение текущей позиции "волны": сэмплы от начала файла
    procedure SetWavePositionBySamples(APosition: Integer);
    function GetWavePositionAsSamples: Integer;

    // Установка и чтение текущей позиции курсора: секунды от начала файла
    procedure SetCursorPositionByTime(APosition: Extended);
    function GetCursorPositionAsTime: Extended;

    // Установка и чтение текущей позиции курсора: сэмплы от начала файла
    procedure SetCursorPositionBySamples(APosition: Integer);
    function GetCursorPositionAsSamples: Integer;

    // Получение дляны композиции в секундах и в сэмплах
    function GetLengthAsTime: Extended;
    function GetLengthAsSamples: Integer;

    // Установка флага автопрокрутки
    procedure SetAutoScroll(AAutoScroll: Boolean);

    function GetFileOpened: boolean;

    procedure FullDisplayedDataGenerate;

  protected
    function DoMouseWheel(Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint): Boolean; override;
    procedure Resize; override;

    property WavData: TWavData read FWavData;

  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure Repaint;
    property NotRepaint: Boolean read FNotRepaint write FNotRepaint;

    // Открывает файл для отображения
    procedure OpenMedia(AFileName: string);
    // Коэффициэнт масштабирования по высоте
    property YScale: Real read FYScale write FYScale;

    // Устанавливает курсор в центр экрана
    procedure ShowCursorAtScreenCenter;

    procedure SendDataToPaintWave();

    // Устанавливает интервал сэмлпов, для отображения на экране
    procedure SetVisibleInterval(FirstSample, LastSample: Integer);
    // Интервал сэмплов, отображаемый на экране
    property Interval: TInterval read FVisibleInterval;
    // Получает количество сэмплов, видимых на экране
    function GetVisibleSamplesCount: Integer;

    // Конвертация экранной координаты в сэмпл
    function SampleByX(ACoordinate: Integer): Integer;
    // Конвертация экранной координаты во время от начала файла
    function TimeByX(ACoordinate: Integer): Extended;

    // Текущее положение отображения "волны" в сэмплах от начала файла
    property WavePositionAsSamples: Integer read GetWavePositionAsSamples write SetWavePositionBySamples;

    // Текущее положение курсора в секундах и сэмплах
    property CursorPositionAsTime: Extended read GetCursorPositionAsTime write SetCursorPositionByTime;
    property CursorPositionAsSamples: Integer read GetCursorPositionAsSamples write SetCursorPositionBySamples;

    // Время указывается в секундах
    property LengthAsTime: Extended read GetLengthAsTime;
    property LengthAsSamples: Integer read GetLengthAsSamples;

    // Файл загружен
    property FileOpened: boolean read GetFileOpened;

  published
    property PaintBox: TWSPaintBox read FPaintBox;
    property ScrollBar: TWSScrollBar read FScrollBar;

    // автопрокрутка вместе с курсором
    property AutoScroll: Boolean read FAutoScroll write SetAutoScroll default True;

  end;


procedure Register;

implementation

uses Variants, Winapi.Windows;

constructor TWaveScreen.Create(AOwner: TComponent);
var GroupPanel: TPanel;
begin
  inherited;

  GroupPanel := TPanel.Create(Self);
  with GroupPanel do
  begin
    Parent := Self;
    Name := 'GroupPanel';
    Caption := '';
    Align := alBottom;
    Height := 25;
  end;

  FScrollBar := TWSScrollBar.Create(Self);
  with FScrollBar do
  begin
    Parent := GroupPanel;
    Name := 'ScrollBar';
    Align := alClient;
  end;

  FPaintBox := TWSPaintBox.Create(Self);
  with FPaintBox do
  begin
    Parent := Self;
    Name := 'PaintBox';
    Align := alClient;
    OnPaint := PaintWS;
  end;

  GroupPanel.ControlStyle := ControlStyle - [csAcceptsControls];

  FWavData := TWavData.Create;
end;

destructor TWaveScreen.Destroy;
begin
  inherited;
end;

function TWaveScreen.DoMouseWheel(Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint): Boolean;
var NewIntervalSize: Integer;
  Deviation: Integer;
  PositionShift: Integer;
begin
  // Запрещаем перерисовку изображения
  NotRepaint := true;

  // Вычисляем новый видимый интервал
  if WheelDelta < 0 then
    NewIntervalSize := Round(GetVisibleSamplesCount * 95 / 100)
  else
    NewIntervalSize := Round(GetVisibleSamplesCount * 100 / 95);

  // Сдвиг позиции ползунка относитель предыдущего значения
  PositionShift := (NewIntervalSize - FScrollBar.PageSize) Div 2;

  // Установка параметров СкролБара
  FScrollBar.PageSize := NewIntervalSize;
  FScrollBar.Position := FScrollBar.Position - PositionShift;

  // Установка нового видимого интервала
  SetVisibleInterval(FScrollBar.Position, FScrollBar.Position + FScrollBar.PageSize);

  // Генерируем видимые данные, исходя из нового диапазона
  FullDisplayedDataGenerate;

  // Перерисовываем изображение
  NotRepaint := false;
  Repaint;

  Result := True;
end;

function TWaveScreen.GetVisibleSamplesCount: Integer;
begin
  Result := FVisibleInterval.Max - FVisibleInterval.Min + 1;
end;

function TWaveScreen.SampleByX(ACoordinate: Integer): Integer;
var RealPos: Extended;
begin
  RealPos := 1.0 * FVisibleInterval.Min + 1.0 * ACoordinate * (FVisibleInterval.Max - FVisibleInterval.Min) / PaintBox.ClientWidth;

  Result := Round(RealPos);
end;

function TWaveScreen.TimeByX(ACoordinate: Integer): Extended;
begin
  Result := SampleByX(ACoordinate) / FWavData.Head.dwSamplesPerSec;
end;

procedure TWaveScreen.Resize;
begin
  inherited;

  // Генерируем полные видимые данные, из-за изменеия масштаба
  FullDisplayedDataGenerate;

  // Рисуем...
  Repaint;
end;

procedure TWaveScreen.SetWavePositionBySamples(APosition: Integer);
begin
  FScrollBar.Position := APosition;
end;

function TWaveScreen.GetWavePositionAsSamples: Integer;
begin
  Result := FScrollBar.Position;
end;

procedure TWaveScreen.SetCursorPositionByTime(APosition: Extended);
var NewPosition: Integer;
begin
  NewPosition := Trunc(APosition * FWavData.Head.dwSamplesPerSec);
  SetCursorPositionBySamples(NewPosition);
end;

function TWaveScreen.GetCursorPositionAsTime: Extended;
begin
  Result := FCursorPosition / FWavData.Head.dwSamplesPerSec;
end;

procedure TWaveScreen.SetCursorPositionBySamples(APosition: Integer);
var Deviation: Integer;
begin

  if AutoScroll then
  begin
    // Запрещаем перерисовку компоненты при установке позиции
    NotRepaint := True;

    //Вычисляем и устанавливаем позицию
    Deviation := APosition - FCursorPosition;
    FScrollBar.Position := FScrollBar.Position + Deviation;

    // Снимаем запрет на перерисовку
    NotRepaint := False;
  end;

  FCursorPosition := APosition;

end;

function TWaveScreen.GetCursorPositionAsSamples: Integer;
begin
  Result := FCursorPosition;
end;

function TWaveScreen.GetLengthAsTime: Extended;
begin
  Result := FWavData.SamplesCount / FWavData.Head.dwSamplesPerSec;
end;

function TWaveScreen.GetLengthAsSamples: Integer;
begin
  Result := FWavData.SamplesCount;
end;

procedure TWaveScreen.FullDisplayedDataGenerate();
var
  NewWidth: Integer;
begin
  // Если начало и конец интервала равны, то выходим. Так быть не должно
  if FVisibleInterval.Max = FVisibleInterval.Min then
    exit;

  // Рассчитываем общее количество отсчётов отображаемых данных исходя из
  // ширины окна и количества сэмплов в файле
  NewWidth := Trunc(ClientWidth / ((FVisibleInterval.Max - FVisibleInterval.Min) / Length(FWavData.Data)));

  // Генерируем полные данные для отображения
  FDisplayedData := FWavData.FullDisplayedDataGenerate(NewWidth, imLine);
end;

procedure TWaveScreen.OpenMedia(AFileName: string);
var SamplesCount: Integer;
  Zoom: Real;
begin

  // Открываем файл и загружаем данные из него
  FWavData.OpenFile(AFileName);
  SamplesCount := FWavData.SamplesCount;

  // Также задаём начальные значения для полосы прокрутки
  FScrollBar.Max := SamplesCount;
  FScrollBar.PageSize := SamplesCount;

  // Определяем масштаб по вертикали исходя из разрядности трека
  case FWavData.Head.wBitsPerSample of
    8:
      FYScale := 256;
    16:
      FYScale := 1;
    32:
      FYScale := 1 / (256 * 256);
  end;

  // Устанавливаем видимым весь диапазон сэмплов
  SetVisibleInterval(0, SamplesCount);

  // Генерируем полные видимые данные, исходя из нового диапазона
  FullDisplayedDataGenerate;

  // И рисуем...
  Repaint;
end;

procedure TWaveScreen.SetVisibleInterval(FirstSample, LastSample: Integer);
var AddToMax, DecFromMin: Integer;
    Ratio: Extended;
    Min, Max, IntervalSize: Integer;
    IntervalMin, IntervalMax: Integer;
    i: Integer;
begin

  // Если первый сэмпл равен последнему, то выходим, так быть не должно
  if FirstSample = LastSample then
    exit;

  // Устанавливаем новый размер полосы прокрутки
  IntervalSize := LastSample - FirstSample + 1;

  // Корректируем размер интервала, в случае если он больше длины трека
  if IntervalSize > WavData.SamplesCount then
    IntervalSize := WavData.SamplesCount;


  FVisibleInterval.Min := FirstSample;
  FVisibleInterval.Max := LastSample;
end;

procedure TWaveScreen.SetAutoScroll(AAutoScroll: boolean);
begin
  FAutoScroll := AAutoScroll;
end;

procedure TWaveScreen.ShowCursorAtScreenCenter;
var NewScrollPosition: Integer;
begin

  NewScrollPosition := FCursorPosition - (FScrollBar.PageSize Div 2);

  if NewScrollPosition < 0 then
    NewScrollPosition := 0;

  if NewScrollPosition + FScrollBar.PageSize > FScrollBar.Max then
    NewScrollPosition := FScrollBar.Max - FScrollBar.PageSize;

  FScrollBar.Position := NewScrollPosition;

end;

procedure TWaveScreen.SendDataToPaintWave;
var
  Ratio: Extended;
  Min: Integer;
  Max: Integer;
begin

  if Not FWavData.FileOpened then
    exit;

  // Рассчитываем отношение количества видимых остчётов к количеству семплов
  // для определения минимального и максимального видимого отсчёта исходя из
  // границ, установленных в сэмплах
  Ratio := Length(FDisplayedData.Min) / FWavData.SamplesCount;
  Min := Round(FVisibleInterval.Min * Ratio);
  Max := Round(FVisibleInterval.Max * Ratio);

  if Assigned(FDisplayedData.Min) then
    FPaintBox.SetDisplayedData(FDisplayedData, Min, Max);

end;

procedure TWaveScreen.Repaint;
begin
  if NotRepaint then
    exit;

  // Посылаем данные для прорисовки
  SendDataToPaintWave;
  FPaintBox.Paint;
end;

procedure TWaveScreen.PaintWS(Sender: TObject);
var
  PaintWave: TWSPaintBox;
  NewLength: integer;
  F: Real;
  i: integer;
  WavData: TWavData;
  Coeff: Real;
  LinePos: Integer;
begin
  inherited;

  PaintWave := TWSPaintBox(Sender);

  if ScrollBar.PageSize = 0 then
    exit;

  with PaintWave do
  begin
    if not Assigned(ScrBitmap) then
      CreateBitmap(ClientWidth, ClientHeight)
    else
      if (ScrBitmap.Width <> ClientWidth) or (ScrBitmap.Height <> ClientHeight) then
        RecreateBitmap(ClientWidth, ClientHeight);

    with ScrBitmap.Canvas do
    begin
      Brush.Color := clBlack;
      FillRect(ClientRect);
      DrawAxis;

      NewLength := Length(FDisplayedData.Max);

      Pen.Color := clLime;
      F := Height * YScale / 65536;

      For i := 0 to NewLength - 1 do
      begin
        MoveTo(i, Height shr 1 - round(FDisplayedData.Max[i] * F));
        LineTo(i, Height shr 1 - round(FDisplayedData.Min[i] * F) + 1);
      end;

      For i := 0 to NewLength - 1 do
      begin
        MoveTo(i, Height shr 1 + round(FDisplayedData.Min[i] * F));
        LineTo(i, Height shr 1 + round(FDisplayedData.Max[i] * F) + 1);
      end;

      Coeff := Width / ScrollBar.PageSize;
      LinePos := Trunc((CursorPositionAsSamples - Interval.Min) * Coeff);
      Pen.Color := clAqua;

      MoveTo(LinePos, 1);
      LineTo(LinePos, Height);
    end;

    Canvas.Draw(0, 0, ScrBitmap);
  end;
end;

function TWaveScreen.GetFileOpened: boolean;
begin
  Result := FWavData.FileOpened;
end;


procedure Register;
begin
  RegisterComponents('WaveScreen', [TWaveScreen]);
end;

end.
